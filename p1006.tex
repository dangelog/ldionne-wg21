\documentclass{wg21}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{minted}
\usepackage{enumitem}

\lstdefinestyle{base}{
  language=c++,
  breaklines=false,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{green!50!black}]{@}{@},
  escapeinside={(*@}{@*)}
}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}


\title{Constexpr in \cc{std::pointer_traits}}
\docnumber{D1006R0}
\audience{LEWG}
\author{Louis Dionne}{ldionne.2@gmail.com}

\begin{document}
\maketitle

\section{Abstract}
As part of the \cc{constexpr} reflection effort, and in particular making
\cc{std::vector} \cc{constexpr}, we need to make \cc{std::pointer_traits}
\cc{constexpr} (it is used in the implementation).


\section{Difficulties}
The standard currently defines a base template \cc{std::pointer_traits} and a
specialization of it for raw pointers (\cc{std::pointer_traits<T*>}). Marking
the base template as \cc{constexpr} would imply that all specializations of it
need to be marked \cc{constexpr} too, since specializations of templates in
namespace \cc{std} for user-defined types need to retain the same interface
as the base template. Indeed, per \textbf{[namespace.std] 20.5.4.2.1/1} in
\cite{N4727}:

\begin{quote}
  The behavior of a C++ program is undefined if it adds declarations or
  definitions to namespace \texttt{std} or to a namespace within namespace
  \texttt{std} unless otherwise specified. A program may add a template
  specialization for any standard library template to namespace \texttt{std}
  only if the declaration depends on a user-defined type and the specialization
  meets the standard library requirements for the original template and is not
  explicitly prohibited.
\end{quote}

However, forcing all specializations of \cc{std::pointer_traits} to be marked
\cc{constexpr} will preclude useful fancy pointer implementations from using
it, such as \cc{offset_ptr}. \cc{offset_ptr} is a pointer represented as an
offset from \cc{this}, which is used in memory mapped files and similar
contexts. The problem with \cc{offset_ptr} is that it uses a \cc{reinterpret_cast}
internally, which isn't allowed in constant expressions (and the barrier to
allowing that is very high).

So marking the base template \cc{constexpr} is not an option without changing
\textbf{[namespace.std]}. The only other option is to mark the specialization
of \cc{std::pointer_traits} for raw pointers (\cc{std::pointer_traits<T*>}) as
\cc{constexpr}, which does not seem to validate \textbf{[namespace.std]} because
it is not a user-provided specialization.

Also note that in practice, we don't expect (and have no use for) \cc{std::vector}
being \cc{constexpr}-friendly for allocators other than the default allocator,
which means that we don't really care about making more than \cc{std::pointer_traits<T*>}
\cc{constexpr}. This is the direction this paper takes.


\section{Proposed wording}
This wording is based on the working draft \cite{N4727}.
Change in \textbf{[pointer.traits] 23.10.3/1}:

\begin{quote}
\begin{codeblock}
namespace std {
  template<class Ptr> struct pointer_traits {
    using pointer         = Ptr;
    using element_type    = @\textit{see below}@;
    using difference_type = @\textit{see below}@;

    template<class U> using rebind = @\textit{see below}@;

    static pointer pointer_to(@\textit{see below}@ r);
  };

  template<class T> struct pointer_traits<T*> {
    using pointer         = T*;
    using element_type    = T;
    using difference_type = ptrdiff_t;

    template<class U> using rebind = U*;

    static @\added{constexpr}@ pointer pointer_to(@\textit{see below}@ r) noexcept;
  };
}
\end{codeblock}
\end{quote}



\section{Acknowledgements}
Thanks to Ion Gazta√±aga for discussing the troubles of \cc{offset_ptr} and
\cc{constexpr} with me.


\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

\bibitem[N4727]{N4727}
  Richard Smith,
  \emph{Working Draft, Standard for Programming Language C++}\newline
  \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4727.pdf}

\end{thebibliography}

\end{document}
