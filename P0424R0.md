<style type="text/css">
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }
blockquote.std { color: #000000; background-color: #F1F1F1;
                 border: 1px solid #D1D1D1;
                 padding-left: 0.5em; padding-right: 0.5em; }
</style>


# Reconsidering literal operator templates for strings

<div style="text-align: right; float: right">
ISO/IEC JTC1 SC22 WG21 <br>
D0424R0 <br>
Louis Dionne <br>
2016-08-03
</div>


## Overview
C++11 added the ability for users to define their own literals suffixes.
Several forms of literal operators are available, but one notable omission
is the literal operator template for string literals:

```c++
template <typename CharT, CharT ...chars>
auto operator"" _udl(); // invalid right now

auto x = "abcd"_udl; // would call operator""_udl<char, 'a', 'b', 'c', 'd'>
```

Furthermore, [N3599][] tried to make this right in 2013 by proposing to add
the missing literal operator, but the paper was rejected at that time with
[the following conclusion][EWG66]:

> Revise with additional machinery for compile time string processing

This short paper asserts that the literal operator template for string
literals should be added as-is to C++, and that no additional machinery
for compile-time string processing should be required for its acceptance.


## Motivation
There are three main reasons why the author thinks [N3599][] should be accepted
without requiring additional compile-time string processing machinery. First,
several use cases for the literal operator template do not require any sort of
compile-time string processing, so the feature would be useful on its own.
Indeed, after writing the [Boost.Hana][] metaprogramming library, several
metaprogramming-inclined individuals have contacted the author of this paper
with problems that were solvable with the literal operator template; none of
them required additional _string processing_ machinery that would be suitable
for inclusion in the standard. These problems would benefit from having better
support for metaprogramming in the standard, but that is a distinct topic.
A simple example of this is implementing named parameters:

```c++
template <char ...s>
struct argument {
  template <typename T>
  std::pair<argument<s...>, T> operator=(T value) {
    return {{}, value};
  }

  template <typename T, typename ...Args>
  auto operator()(std::pair<argument<s...>, T> a, Args ...) const {
    return a.second;
  }

  template <typename Arg, typename ...Args>
  auto operator()(Arg, Args ...args) const {
    static_assert(sizeof...(Args) != 0, "missing argument");
    return (*this)(args...);
  }
};

template <typename CharT, CharT ...s>
argument<s...> operator"" _arg() { return {}; }

template <typename ...Args>
void create_window(Args ...args) {
  int x = "x"_arg(args...);
  int y = "y"_arg(args...);
  int width = "width"_arg(args...);
  int height = "width"_arg(args...);
  // etc...
}

int main() {
  create_window("x"_arg = 20, "y"_arg = 50, "width"_arg = 100, "height"_arg = 5);
}
```

> This is for illustration only. In a real implementation, one would be wary
> of not copying the arguments unless necessary, marking functions `constexpr`
> and `noexcept` whenever possible, etc...

Here, no string processing whatsoever is required. Also, while finding the
first `pair` of the parameter pack whose first element represents the right
argument would benefit from additional machinery, the author believes that to
be completely orthogonal to the current proposal. Also of interest is to note
that the example above uses compile-time strings solely to associate a unique
tag to a value, a pattern which arises very commonly in C++ metaprogramming.
Thus, use cases abound and the proposed feature could for instance be used to
eliminate the explicit declaration of tags in the following code:

```c++
namespace tags { struct name; struct age; } // need to declare tags beforehand

BOOST_FUSION_DEFINE_ASSOC_STRUCT(
  /* global scope */, Person,
  (std::string, name, tags::name)
  (int, age, tags::age)
)

int main() {
    Person john{"John", 30};
    std::string name = at_key<tags::name>(john);
    int age = at_key<tags::age>(john);
}
```

Indeed, with the proposed feature, the above code can become

```c++
struct Person {
  BOOST_HANA_DEFINE_STRUCT(Person,
    (std::string, name),
    (int, age)
  );
};

int main() {
  Person john{"John", 30};
  std::string name = at_key(john, "name"_s);
  int age = at_key(john, "age"_s);
}
```

In situations where the number of tags is large, separate tag declarations can
be very tedious to keep in sync with the original structure. Instead, it is
much better if the library is able to relate the `name` in the structure
definition to the `name` used in the `main` function without an additional
tag declaration.

> Even better would be proper support for static reflection, but this is beyond
> the scope of this paper. Also, not all problems where the proposed feature
> would be useful can be solved with static reflection, so one is not a
> substitute for the other.

Secondly, the proposed feature is already implemented in Clang and GCC, and it
is getting wider and wider usage. The author assumes the feature to be easy to
support for implementations, and thinks that it should be standardized instead
of letting its availability vary across compilers. This would make the life of
users easier instead of forcing them to use ugly workarounds such as the
following to comply with the standard:

```c++
template <char ...s>
struct argument {
  // ... as before ...
};

template <std::size_t ...N, typename Literal>
argument<Literal::get(N)...> make_argument(std::index_sequence<N...>, Literal) {
  return {};
}

#define MAKE_ARGUMENT(LITERAL)                                              \
  make_argument(std::make_index_sequence<sizeof(LITERAL)-1>{}, []{          \
    struct Literal {                                                        \
      static constexpr char get(int i) { return LITERAL[i]; }               \
    };                                                                      \
    return Literal{};                                                       \
  }())                                                                      \
/**/

// ... as before ...

int main() {
  create_window(MAKE_ARGUMENT("x") = 20, MAKE_ARGUMENT("y") = 50,
                MAKE_ARGUMENT("width") = 100, MAKE_ARGUMENT("height") = 5);
}
```

Finally, defining string processing machinery is so non-trivial that even
runtime C++ lacks any useful form of it. The author thinks that dismissing
the proposed feature for lack of such machinery is unwise, since it blocks
a lot of use cases that are very basic in their string processing requirements
for the benefit of a few more advanced use cases. Furthermore, going forward
with this feature does not block us in any way from adding more advanced
machinery to the language later on. In fact, it may very well allow us to
gain more experience with what kind of machinery would be useful.


## Proposed wording
The wording initially proposed in [N3599][] still applies to the current draft
([N4606][]), and so it should be used. For convenience, it is copied here from
the original paper:

The term of art _literal operator template_ is split into two terms, _numeric
literal operator template_ and _string literal operator template_. The term
_literal operator template_ is retained and refers to either form.

Replace "literal operator template" with "numeric literal operator template"
in __\[lex.ext\] (2.14.8)/3__ and __\[lex.ext\] (2.14.8)/4__:

<blockquote class="std">
  [...] Otherwise, <i>S</i> shall contain a raw literal operator or a
  <ins>numeric</ins> literal operator template (13.5.8) but not both. [...]
  Otherwise (<i>S</i> contains a <ins>numeric</ins> literal operator template),
  <i>L</i> is treated as a call of the form [...]
</blockquote>

Change in __\[lex.ext\] (2.14.8)/5__:

<blockquote class="std">
  If <i>L</i> is a <i>user-defined-string-literal</i>, <ins>let <i>C</i> be the
  element type of the string literal as determined by its
  <i>encoding-prefix</i>,</ins> let <i>str</i> be the literal without its
  <i>ud-suffix</i><ins>,</ins> and let <i>len</i> be the number of code units in
  <i>str</i> (i.e., its length excluding the terminating null character).
  <ins>If <i>S</i> contains a literal operator with parameter types <code>const
  <i>C</i> *</code> and <code>std::size_t</code>, the</ins> <del>The</del> literal
  <i>L</i> is treated as a call of the form</p>

  <code>&nbsp; operator "" <i>X</i>(<i>str</i>, <i>len</i>)</code>

  <ins>
  <p>Otherwise, <i>S</i> shall contain a string literal operator template
  (13.5.8), and <i>L</i> is treated as a call of the form</p>

  <code>&nbsp; operator "" <i>X</i>&lt;<i>C</i>,
    <i>e</i>'<i>s<sub>1</sub></i>',
    <i>e</i>'<i>s<sub>2</sub></i>', ...
    <i>e</i>'<i>s<sub>k</sub></i>'&gt;()</code></p>

  where <i>e</i> is empty when the <i>encoding-prefix</i> is <code>u8</code>
  and is otherwise the <i>encoding-prefix</i> of the string literal, and
  <i>str</i> contains the sequence of code units
  <i>s<sub>1</sub>s<sub>2</sub>...s<sub>k</i> (excluding the terminating null
  character).
  </ins>
</blockquote>

Change in __\[over.literal\] (13.5.8)/5__:

<blockquote class="std">
  <del>
  The declaration of a literal operator template shall have an empty
  <i>parameter-declaration-clause</i> and its <i>template-parameter-list</i>
  shall have
  </del>

  <ins>A <i>numeric literal operator template</i> is a literal operator template
  whose <i>template-parameter-list</i> has</ins>

  a single <i>template-parameter</i> that is a non-type template parameter pack
  (14.5.3) with element type <code>char</code>.

  <ins>A <i>string literal operator template</i> is a literal operator template
  whose <i>template-parameter-list</i> comprises
  a type <i>template-parameter</i> <i>C</i> followed by a non-type template
  parameter pack with element type <i>C</i>.

  The declaration of a literal operator template shall have an empty
  <i>parameter-declaration-clause</i> and shall declare either a numeric literal
  operator template or a string literal operator template.
  </ins>
</blockquote>


## Acknowledgements
Richard Smith for doing all the hard work in [N3599][].



<!-- Links -->
[1]: https://groups.google.com/a/isocpp.org/d/msg/std-proposals/YtIPoZ4ESMI/8yi0FkWsy4wJ
[Boost.Hana]: https://github.com/boostorg/hana
[EWG66]: http://cplusplus.github.io/EWG/ewg-active.html#66
[N3599]: http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html
[N4606]: https://github.com/cplusplus/draft/blob/master/papers/n4606.pdf
