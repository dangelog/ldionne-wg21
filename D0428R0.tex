\documentclass[11pt]{article}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{minted}
\usepackage{textcomp}
\usepackage{upquote}

\lstdefinestyle{base}{
  language=c++,
  breaklines=false,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{green!50!black}]{@}{@},
  escapeinside={(*@}{@*)}
}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}
\newcommand{\added}[1]{\sethlcolor{green}{\hl{#1}}}
\newcommand{\deleted}[1]{\sethlcolor{red}{\hl{#1}}}

\date{}
\title{Familiar template syntax for generic lambdas}
\author{}


\begin{document}

\maketitle\vspace{-2cm}

\begin{flushright}
  \begin{tabular}{ll}
  Document \#:&D0428R0\\
  Date:       &\date{2016-09-08}\\
  Project:    &Programming Language C++\\
  Audience:   &Evolution Working Group\\
  Reply-to:   &\author{Louis Dionne} \textless\href{mailto:ldionne.2@gmail.com}{ldionne.2@gmail.com}\textgreater
  \end{tabular}
\end{flushright}


\section{Introduction}
C++14 added the ability to define generic lambdas, i.e. lambdas where the
\cc{operator()} of the generated \textit{closure-type} is a template. This
addition was initially proposed in \cite{N3418}, which included many different
features for generic lambdas, including the functionality proposed by this
paper. However, N3418 was not accepted as-is and its successor,
\cite{N3559}, was accepted instead. N3559 settled on the \cc{auto}-based
syntax that we know in C++14 for defining generic lambdas, leaving the
usual template syntax out for lack of clear use cases (according to an author
of N3559):

\begin{cpp}
[](auto x) { /* ... */ }
\end{cpp}

Unfortunately, this syntax makes it difficult to interact with the type of the
parameter(s) and lacks flexibility that is sometimes required, as outlined in
the \nameref{motivation} section. Hence, this paper proposes adding the ability
to use the familiar template syntax when defining lambda expressions:

\begin{cpp}
[]<typename T>(T x) { /* ... */ }
[]<typename T>(T* p) { /* ... */ }
[]<typename T, int N>(T (&a)[N]) { /* ... */ }
\end{cpp}


\section{Motivation} \label{motivation}
There are a few key reasons why the current syntax for defining generic lambdas
is deemed insufficient by the author. The gist of it is that some things that
can be done easily with normal function templates require significant hoop
jumping to be done with generic lambdas, or can't be done at all. The author
thinks that lambdas are valuable enough that C++ should support them just as
well as normal function templates. The following details such areas where
lambdas are lacking in their current form:

\begin{enumerate}
\item
The limited form of "pattern matching" on template argument allowed by C++
in function templates is very useful, and it would be equally useful to allow
it in lambda expressions. For example, writing a lambda that accepts a
\cc{std::vector} containing elements of any type (but not another container)
is not possible with the current syntax for generic lambdas. Instead, one
must write a catch-all generic lambda that accepts any type, and then assume
that it is of the proper type, or check that it is not through other means:

\begin{cpp}
template <typename T> struct is_std_vector                 : std::false_type { };
template <typename T> struct is_std_vector<std::vector<T>> : std::true_type { };

auto f = [](auto vector) {
  static_assert(is_std_vector<decltype(vector)>::value, "");
};
\end{cpp}

In addition to being verbose, calling the lambda with a type that is not a
\cc{std::vector} will result in a hard error inside the body of the lambda, not
a template argument deduction failure. This does not play nicely with other
parts of the language such as SFINAE-based detection, and it is obviously
not as clear as the equivalent function template.

Another instance where "pattern matching" would be useful is to deconstruct
the type of arguments that are template specializations. For example, imagine
that we want to get the type of elements stored in the vector in the previous
example. Right now, we'd have to write this:

\begin{cpp}
auto f = [](auto vector) {
  using T = typename decltype(vector)::value_type;
  // ...
};
\end{cpp}

This is cumbersome syntax-wise, and it requires the type to provide a nested
alias that does just the right thing. This is not a problem for \cc{std::vector},
but most types don't provide such aliases (and in many cases it wouldn't make
sense for them to). Hence, right now, types that do not provide nested aliases
or accompanying metafunctions can simply not be deconstructed in lambdas.
Instead, it would be much simpler and more flexible to write

\begin{cpp}
auto f = []<typename T>(std::vector<T> vector) {
  // ...
};
\end{cpp}


\item
It is often useful to retrieve the type of the parameter of a generic
lambda, e.g. for accessing a static member function or an alias nested
inside it. However, retrieving such a type requires using \cc decltype,
which includes its reference and cv qualifiers. This can often lead to
unexpected results:

\begin{cpp}
auto f = [](auto const& x) {
  using T = decltype(x);
  T copy = x;                             // Compiles, but wrong semantics!
  T::static_function();                   // Does not compile!
  using Iterator = typename T::iterator;  // Does not compile!
};
\end{cpp}

To work around this unfortunate situation, one must introduce some
amount of verbosity:

\begin{cpp}
auto f = [](auto const& x) {
  using T = std::decay_t<decltype(x)>;
  T copy = x;
  T::static_function();
  using Iterator = typename T::iterator;
};
\end{cpp}

Furthermore, this problem compounds when trying to make a parameter type
dependent on a previous parameter type, because aliases can't be introduced
in that context to reduce verbosity:

\begin{cpp}
auto advance = [](auto& it,
                  typename std::decay_t<decltype(it)>::difference_type n) {
  // ...
};
\end{cpp}

Instead, it would be much nicer and closer to usual templates if we could
simply write

\begin{cpp}
auto f = []<typename T>(T const& x) {
  T copy = x;
  T::static_function();
  using Iterator = typename T::iterator;
};

auto advance = []<typename It>(It& it, typename It::difference_type n) {
  // ...
};
\end{cpp}


\item
Perfect forwarding in generic lambdas is more verbose than it needs to
be, and the syntax for it is different from what's usually done in normal
function templates. While this is technically a direct corollary of the
previous point, the author thinks this is sufficiently annoying to be
worth mentioning separately. The problem is that since the only way to
get an argument's type in a lambda is to use \cc decltype, we must resort
to the following syntax for perfect forwarding:

\begin{cpp}
auto f = [](auto&& ...args) {
  return foo(std::forward<decltype(args)>(args)...);
};
\end{cpp}

Exactly why this works is explained in a blog post written by Scott Meyers
\cite{Meyers}, but the very fact that Meyers had to write a blog post about
it is telling. Indeed, the interaction between template argument deduction
and reference collapsing rules is already sufficiently complicated that many
C++ users would benefit from the cognitive load reduction allowed by a single
perfect forwarding syntax for both lambdas and normal functions:

\begin{cpp}
auto f = []<typename ...T>(T&& ...args) {
  return foo(std::forward<T>(args)...);
};
\end{cpp}
\end{enumerate}


\section{Proposed Wording}
Change in 5.1.5 \textbf{[expr.prim.lambda]/1}:

\textit{lambda-expression:}\newline
  \hspace*{0.5cm} \textit{lambda-introducer}
    \hspace{0.1cm} \added{\textbf\textless \textit{template-parameter-list} \textbf\textgreater$_{opt}$}
    \hspace{0.1cm} \textit{lambda-declarator}$_{opt}$
    \hspace{0.1cm} \textit{compound-statement}

Change in 5.1.5 \textbf{[expr.prim.lambda]/6}:

\begin{quote}
  The closure type for a non-generic \textit{lambda-expression} has a public
  inline function call operator (13.5.4) whose parameters and return type are
  described by the \textit{lambda-expression}'s \textit{parameter-declaration-clause}
  and \textit{trailing-return-type} respectively. For a generic lambda, the
  closure type has a public inline function call operator member template
  (14.5.2) whose \textit{template-parameter-list} consists of \added{the
  specified \textit{template-parameter-list}, if any, to which is appended}
  one invented type \textit{template-parameter} for each occurrence of \cc{auto}
  in the lambda's \textit{parameter-declaration-clause}, in order of appearance.
  The invented type \textit{template-parameter} is a parameter pack if the
  corresponding \textit{parameter-declaration} declares a function parameter
  pack (8.3.5). The return type and function parameters of the function call
  operator template are derived from the \textit{lambda-expression}'s
  \textit{trailing-return-type} and \textit{parameter-declaration-clause} by
  replacing each occurrence of \cc{auto} in the \textit{decl-specifier}s of
  the \textit{parameter-declaration-clause} with the name of the corresponding
  invented \textit{template-parameter}.
\end{quote}

Change in 5.1.5 \textbf{[expr.prim.lambda]/7}:

\begin{quote}
  [\dots] For a generic lambda with no \textit{lambda-capture}, the closure type
  has a conversion function template to pointer to function. The conversion function
  template has the same \deleted{invented} \textit{template-parameter-list},
  and the pointer to function has the same parameter types, as the function
  call operator template. [\dots]
\end{quote}


\section{Implementation experience}
This extension to generic lambdas had been implemented in GCC in 2009 as part
of an experiment \cite{GCC}. Thus, it seems implementable.


\section{Discussion} \label{discussion}
There were very few controversial decisions to make in the writing of this
paper. The only one was whether to allow a lambda to contain both a
\textit{template-parameter-list} and conventional \cc{auto}-based parameters.
When allowing both syntaxes, we must make a choice regarding the position of
the invented template parameters relative to the specified template parameters:

\begin{cpp}
[]<typename T>(T, auto) // => template <typename T, typename Invented>
[]<typename T>(auto, T) // => template <typename Invented, typename T>
[]<typename T>(auto)    // could be either of the above
\end{cpp}

Note that it \textit{does} make sense to write the third lambda expression,
because we can access the function call operator of a lambda explicitly and
thus specify a value for \cc T:

\begin{cpp}
auto f = []<typename T>(auto x) { };
f.operator()<int, char>(...);
\end{cpp}

We decided to allow mixing both syntaxes and decided to append the invented
template parameters to the end of the \textit{template-parameter-list}, because
it seems like the simplest choice, it does not limit expressiveness in any way
and it is consistent with what's done in the proposal for concepts \cite{N4553}.
In case this choice is deemed the wrong one, this paper can easily be amended
to disallow lambdas from using both the familiar template syntax and \cc{auto}
parameters.

\section{Acknowledgements}
Thanks to Tom Honermann, Nicol Bolas and other members of the \textit{std-proposal}
mailing list for providing comments to improve this paper.


\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

  \bibitem[N4606]{N4606}
    Richard Smith,
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://github.com/cplusplus/draft/blob/master/papers/n4606.pdf}

  \bibitem[Meyers]{Meyers}
    Scott Meyers,
    \emph{C++14 Lambdas and Perfect Forwarding}\newline
    \url{http://scottmeyers.blogspot.com.tr/2013/05/c14-lambdas-and-perfect-forwarding.html}

  \bibitem[N3418]{N3418}
    Faisal Vali, Herb Sutter, Dave Abrahams,
    \emph{Proposal for Generic (Polymorphic) Lambda Expressions}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3418.pdf}

  \bibitem[N3559]{N3559}
    Faisal Vali, Herb Sutter, Dave Abrahams,
    \emph{Proposal for Generic (Polymorphic) Lambda Expressions (Revision 2)}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3559.pdf}

  \bibitem[GCC]{GCC}
    Adam Butcher,
    \emph{Latest experimental polymorphic lambda patches}\newline
    \url{http://gcc.gnu.org/ml/gcc/2009-08/msg00174.html}

  \bibitem[N4553]{N4553}
    Andrew Sutton,
    \emph{Working Draft, C++ extensions for Concepts}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf}

\end{thebibliography}

\end{document}



% 2. can't have a parameter pack `using Ts... = decltype(ts)...` to workaround the hiding problem explained below, if any

% TODO: Is this concern even real?
% ------------------------------------------------------------------------------
% 4. Having to use `decltype(x)` to retrieve the type of a parameter named `x`
%    ties that type to the result of evaluating this expression in the current
%    scope. For example, consider the following code:

%   ```c++
%   auto f = [](auto x) {
%     {
%       // 'decltype(x)' is 'char', as deduced
%       int x = 1;
%       // 'decltype(x)' is now 'int'
%     }
%   };

%   f('a');
%   ```

%   Now, while this makes perfect sense in most cases, making `decltype(x)` the
%   only way of retrieving the type of a parameter can lead to confusing situations:

%   ```c++
%   auto f = [](auto&& x) {
%     // decltype(x) is 'char&&', as deduced
%     [&] {
%       (void)x; // use 'x' anywhere in the body of this lambda
%       // decltype(x) is now 'char&', because of the capture by reference
%     };
%   };

%   f('a');
%   ```

%   To work around this limitation, one has to use a temporary alias [...]

%    can have unexpected results in some cases, since `decltype(x)` is the type
%    of `x` _within the current scope_. For example, consider the following code,
%    which implements partial function application with perfect forwarding of the
%    arguments:

%   ```c++
%   auto apply_partially = [](auto f, auto&& arg0) {
%     return [&](auto&& ...args) {
%       return f(std::forward<decltype(arg0)>(arg0), std::forward<decltype(args)>(args)...);
%       //                    ^^^^^^^^^^^^^^ Incorrect!
%     };
%   };

%   std::vector<std::string>
%   std::count(v.begin(), v.end(), apply_partially(std::plus<>{}, ))
%   ```

%   Here, capturing `arg0` has the effect of changing the result of `decltype(arg0)`
%   inside the inner lambda. For example, if `auto&& arg0` was deduced as
%   `std::string&& arg0` in the outer lambda, `std::forward<decltype(arg0)>(arg0)`
%   would forward `arg0` as a `std::string&` inside the inner lambda, which is
%   not what is wanted in this case. This behavior is of course expected after
%   reasoning it through, but it is unfortunate that C++ makes such confusing
%   constructs almost inevitable when working with lambdas. If one wants the
%   "original" type of the argument, an alias has to be used:

%   ```c++
%   auto apply_partially = [](auto f, auto&& arg0) {
%     using Arg0 = decltype(arg0);
%     return [&](auto&& ...args) {
%       // Here use std::forward<Arg0> instead of std::forward<decltype(arg0)>
%       return f(std::forward<Arg0>(arg0), std::forward<decltype(args)>(args)...);
%     };
%   };
%   ```
