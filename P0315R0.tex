\documentclass[11pt]{article}

\usepackage{xcolor}
\usepackage{fullpage}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage{listings}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{minted}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}


\date{}
\title{Lambdas in unevaluated contexts}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},           % group identifier
  morecomment=[f][\color{red}]{-},             % deleted lines
  morecomment=[f][\color{green!50!black}]{+},  % added lines
  morecomment=[f][\color{magenta}]{---},       % diff header lines
  morecomment=[f][\color{magenta}]{+++},
}

\newcommand{\added}[1]{\color{green}{#1}}

\lstset{
  basicstyle=\footnotesize\ttfamily,
}

\begin{document}

\maketitle\vspace{-2cm}

\begin{flushright}
  \begin{tabular}{ll}
  Document \#:&P0315R0\\
  Date:       &\date{2016-05-24}\\
  Project:    &Programming Language C++\\
              &Evolution Group\\
  Reply-to:   &\author{Louis Dionne} \textless\href{mailto:ldionne.2@gmail.com}{ldionne.2@gmail.com}\textgreater
  \end{tabular}
\end{flushright}


\section{Introduction}
Lambdas are a very powerful language feature, especially when it comes to using
higher-order algorithms with custom predicates or expressing small, disposable
pieces of code. Yet, they suffer from one important limitation which cripples their
usefulness for creative use cases; they can't appear in unevaluated contexts. This
draconian restriction was originally designed to prevent lambdas from appearing in
signatures, which would have opened a can of worm for mangling because lambdas are
required to have unique types. However, that restriction was neither necessary nor
sufficient to implement that intent, a situation that has been resolved when
\href{http://goo.gl/rJey8q}{core issue 1607} was addressed in C++14. Furthermore,
as the core issue states, the restriction is now stale, since the core issue was
addressed:

\begin{displayquote}
If any of these approaches were adopted, the rationale for disallowing lambda-expressions
in unevaluated operands would be removed, so it might make sense to remove the restriction
at the same time.
\end{displayquote}

This paper proposes repairing that oversight and lifting the restriction that lambdas
can't appear in unevaluated contexts.


\section{Motivation}
The original use case that motivated this article is related to making algorithms
on heterogeneous containers more useful. For a bit of background, it is possible
to implement \cc{std}-like algorithms that operate on \cc{std::tuple}s instead of
usual, runtime sequences. For example, it is possible to write an algorithm akin
to \cc{std::sort}, but which works on a \cc{std::tuple} instead of a runtime
sequence:

\begin{cpp}
// Returns a new tuple whose elements are sorted according to the given
// binary predicate, which must return a boolean `std::integral_constant`.
template <typename ...T, typename Predicate>
auto sort(std::tuple<T...> const& tuple, Predicate const& pred);
\end{cpp}

The algorithm can then be used as follows:

\begin{cpp}
auto tuple = std::make_tuple(std::array<int, 5>{}, 1, '2', 3.3);
auto sorted = sort(tuple, [](auto const& a, auto const& b) {
  return std::integral_constant<bool, sizeof(a) < sizeof(b)>{};
});
// sorted is now a std::tuple<char, int, double, std::array<int, 5>>
\end{cpp}

While this is a simplified example, it is also possible to define other algorithms
like \cc{for_each}, \cc{transform}, \cc{accumulate}, \cc{find_if} and many more. This
is exploited extensively in the \cite{Boost.Hana} library, which provides high-level
algorithms and data structures to make metaprogramming more structured.

Where the current proposal meets with the above use case is when one needs the type
resulting from an algorithm exposed above. For example, to get the type of the above
tuple without actually creating the tuple, one would like to simply write

\begin{cpp}
using sorted = decltype(sort(tuple, [](auto const& a, auto const& b) {
  return std::integral_constant<bool, sizeof(a) < sizeof(b)>{};
}));
\end{cpp}

Unfortunately, with the current restriction on lambdas, this is impossible.
Instead, one must create a variable holding the lambda, and then pass this
variable to the algorithm:

\begin{cpp}
auto predicate = [](auto const& a, auto const& b) {
  return std::integral_constant<bool, sizeof(a) < sizeof(b)>{};
};
using sorted = decltype(sort(tuple, predicate));
\end{cpp}

Unfortunately, this is both clumsy and not always possible since some contexts
do not allow defining local variables (for example inside a class declaration).
Hence, the restriction severly reduces the usefulness of lambdas in these algorithms.
Also note that the issue presented above does not only arise in the context of
manipulating heterogeneous containers. Indeed, one could just as well try to
write the following, only to be puzzled by a compiler error:

\begin{cpp}
std::vector<int> v{1,2,3,4};
using Iterator = decltype(std::find_if(begin(v), end(v), [](int i) {
  return i % 2 == 0;
}));
\end{cpp}

While this is a valid use case, it is expected that using \cc{decltype} on
such a complex expression is less frequent outside the realm of heterogeneous
computations.

Finally, another motivation for this paper is that the restriction is now
obsolete, yet it needlessly prevents lambdas from being used in creative ways,
some of which are certainly unknown to the author of this paper. Quoting
\href{https://goo.gl/ysUIdv}{an exchange} between Richard Smith and Roland
Bock on the std-proposal mailing list:

\begin{verbatim}
    > > > > If we remove the (now-redundant) restriction on lambdas in unevaluated
    > > > > operands, you could write: [...]
    > > >
    > > > Are there plans/proposals to do that? I stumbled over this restriction
    > > > quite a few times.
    > >
    > > I don't think it's on the core issues list. We discussed it while working
    > > on core issue 1607, but I think we thought it would be best handled
    > > separately.
    >
    > Can you give me a pointer as to why the restriction is redundant now?

    See core issue 1607. The purpose of the restriction was to avoid lambda-
    expressions appearing in a signature (so that implementations don't need to
    implement declaration / statement SFINAE and don't need to mangle them), but
    it was neither necessary nor sufficient for that. The new rules in core issue
    1607 don't need this restriction to implement that intent.
\end{verbatim}

Hence, we feel like it would now be reasonable for the restriction to be lifted.


\section{Proposed Wording}
The proposed wording is probably incomplete, for the author lacks sufficiently deep
knowledge of the standard to be sure that no other sections are impacted. However,
preliminary survey suggests that only the following change would be required
(based on the working paper \cite{N4296}):

\begin{itemize}
    \item[] \textbf{In [expr.prim.lambda] 5.1.2/2:}
    Remove \textit{unevaluated operand} from the list of things a lambda-expression
    may not appear in.
\end{itemize}


\section{Implementation Experience}
This proposal was implemented in Clang. The required change is commenting a single line
which creates a diagnostic if a lambda-expression is found inside an unevaluated context.


\section{Acknowledgements}
Roland Bock and Matt Calabrese for discussing use cases for lambdas in unevaluated contexts
on the \textit{std-proposal} and \textit{Boost.Devel} mailing lists. Richard Smith for letting
me know that the restriction was now redundant.


\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

  \bibitem[Boost.Hana]{Boost.Hana}
    Louis Dionne,
    \emph{Boost.Hana, A modern metaprogramming library}\newline
    \url{https://github.com/boostorg/hana}

  \bibitem[N4296]{N4296}
    Richard Smith,
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf}

\end{thebibliography}

\end{document}
