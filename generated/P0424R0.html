<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}

</style>

<style type="text/css">
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }
blockquote.std { color: #000000; background-color: #F1F1F1;
                 border: 1px solid #D1D1D1;
                 padding-left: 0.5em; padding-right: 0.5em; }
</style>


<title>P0424R0</title></head><body><article class="markdown-body">

<h1>
<a id="user-content-reconsidering-literal-operator-templates-for-strings" class="anchor" href="#reconsidering-literal-operator-templates-for-strings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reconsidering literal operator templates for strings</h1>

<div>
ISO/IEC JTC1 SC22 WG21 <br>
D0424R0 <br>
Louis Dionne <br>
2016-08-03
</div>

<h2>
<a id="user-content-overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>

<p>C++11 added the ability for users to define their own literals suffixes.
Several forms of literal operators are available, but one notable omission
is the literal operator template for string literals:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> CharT, CharT ...chars&gt;
<span class="pl-k">auto</span> <span class="pl-k">operator</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> _udl(); <span class="pl-c">// invalid right now</span>

<span class="pl-k">auto</span> x = <span class="pl-s"><span class="pl-pds">"</span>abcd<span class="pl-pds">"</span></span>_udl; <span class="pl-c">// would call operator""_udl&lt;char, 'a', 'b', 'c', 'd'&gt;</span></pre></div>

<p>Furthermore, <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html">N3599</a> tried to make this right in 2013 by proposing to add
the missing literal operator, but the paper was rejected at that time with
<a href="http://cplusplus.github.io/EWG/ewg-active.html#66">the following conclusion</a>:</p>

<blockquote>
<p>Revise with additional machinery for compile time string processing</p>
</blockquote>

<p>This short paper asserts that the literal operator template for string
literals should be added as-is to C++, and that no additional machinery
for compile-time string processing should be required for its acceptance.</p>

<h2>
<a id="user-content-motivation" class="anchor" href="#motivation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Motivation</h2>

<p>There are three main reasons why the author thinks <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html">N3599</a> should be accepted
without requiring additional compile-time string processing machinery. First,
several use cases for the literal operator template do not require any sort of
compile-time string processing, so the feature would be useful on its own.
Indeed, after writing the <a href="https://github.com/boostorg/hana">Boost.Hana</a> metaprogramming library, several
metaprogramming-inclined individuals have contacted the author of this paper
with problems that were solvable with the literal operator template; none of
them required additional <em>string processing</em> machinery that would be suitable
for inclusion in the standard. These problems would benefit from having better
support for metaprogramming in the standard, but that is a distinct topic.
A simple example of this is implementing named parameters:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template </span>&lt;<span class="pl-k">char</span> ...s&gt;
<span class="pl-k">struct</span> <span class="pl-en">argument</span> {
  <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
  std::pair&lt;argument&lt;s...&gt;, T&gt; <span class="pl-k">operator</span>=(T value) {
    <span class="pl-k">return</span> {{}, value};
  }

  <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T, <span class="pl-k">typename</span> ...Args&gt;
  <span class="pl-k">auto</span> <span class="pl-en">operator</span>()(std::pair&lt;argument&lt;s...&gt;, T&gt; a, Args ...) <span class="pl-k">const</span> {
    <span class="pl-k">return</span> a.<span class="pl-smi">second</span>;
  }

  <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> Arg, <span class="pl-k">typename</span> ...Args&gt;
  <span class="pl-k">auto</span> <span class="pl-en">operator</span>()(Arg, Args ...args) <span class="pl-k">const</span> {
    <span class="pl-c1">static_assert</span>(<span class="pl-k">sizeof</span>...(Args) != <span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>missing argument<span class="pl-pds">"</span></span>);
    <span class="pl-k">return</span> (*<span class="pl-v">this</span>)(args...);
  }
};

<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> CharT, CharT ...s&gt;
argument&lt;s...&gt; <span class="pl-k">operator</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> _arg() { <span class="pl-k">return</span> {}; }

<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> ...Args&gt;
<span class="pl-k">void</span> <span class="pl-en">create_window</span>(Args ...args) {
  <span class="pl-k">int</span> x = <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span><span class="pl-c1">_arg</span>(args...);
  <span class="pl-k">int</span> y = <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span><span class="pl-c1">_arg</span>(args...);
  <span class="pl-k">int</span> width = <span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span><span class="pl-c1">_arg</span>(args...);
  <span class="pl-k">int</span> height = <span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span><span class="pl-c1">_arg</span>(args...);
  <span class="pl-c">// etc...</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  <span class="pl-c1">create_window</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>_arg = <span class="pl-c1">20</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>_arg = <span class="pl-c1">50</span>, <span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span>_arg = <span class="pl-c1">100</span>, <span class="pl-s"><span class="pl-pds">"</span>height<span class="pl-pds">"</span></span>_arg = <span class="pl-c1">5</span>);
}</pre></div>

<blockquote>
<p>This is for illustration only. In a real implementation, one would be wary
of not copying the arguments unless necessary, marking functions <code>constexpr</code>
and <code>noexcept</code> whenever possible, etc...</p>
</blockquote>

<p>Here, no string processing whatsoever is required. Also, while finding the
first <code>pair</code> of the parameter pack whose first element represents the right
argument would benefit from additional machinery, the author believes that to
be completely orthogonal to the current proposal. Also of interest is to note
that the example above uses compile-time strings solely to associate a unique
tag to a value, a pattern which arises very commonly in C++ metaprogramming.
Thus, use cases abound and the proposed feature could for instance be used to
eliminate the explicit declaration of tags in the following code:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">namespace</span> <span class="pl-en">tags</span> { <span class="pl-k">struct</span> <span class="pl-en">name</span>; <span class="pl-k">struct</span> <span class="pl-en">age</span>; } <span class="pl-c">// need to declare tags beforehand</span>

<span class="pl-en">BOOST_FUSION_DEFINE_ASSOC_STRUCT</span>(
  <span class="pl-c">/* global scope */</span>, Person,
  (std::string, name, tags::name)
  (<span class="pl-k">int</span>, age, tags::age)
)

int main() {
    Person john{<span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">30</span>};
    std::string name = at_key&lt;tags::name&gt;(john);
    <span class="pl-k">int</span> age = at_key&lt;tags::age&gt;(john);
}</pre></div>

<p>Indeed, with the proposed feature, the above code can become</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">Person</span> {
  <span class="pl-en">BOOST_HANA_DEFINE_STRUCT</span>(Person,
    (std::string, name),
    (<span class="pl-k">int</span>, age)
  );
};

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  Person john{<span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">30</span>};
  std::string name = <span class="pl-c1">at_key</span>(john, <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>_s);
  <span class="pl-k">int</span> age = <span class="pl-c1">at_key</span>(john, <span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>_s);
}</pre></div>

<p>In situations where the number of tags is large, separate tag declarations can
be very tedious to keep in sync with the original structure. Instead, it is
much better if the library is able to relate the <code>name</code> in the structure
definition to the <code>name</code> used in the <code>main</code> function without an additional
tag declaration.</p>

<blockquote>
<p>Even better would be proper support for static reflection, but this is beyond
the scope of this paper. Also, not all problems where the proposed feature
would be useful can be solved with static reflection, so one is not a
substitute for the other.</p>
</blockquote>

<p>Secondly, the proposed feature is already implemented in Clang and GCC, and it
is getting wider and wider usage. The author assumes the feature to be easy to
support for implementations, and thinks that it should be standardized instead
of letting its availability vary across compilers. This would make the life of
users easier instead of forcing them to use ugly workarounds such as the
following to comply with the standard:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template </span>&lt;<span class="pl-k">char</span> ...s&gt;
<span class="pl-k">struct</span> <span class="pl-en">argument</span> {
  <span class="pl-c">// ... as before ...</span>
};

<span class="pl-k">template </span>&lt;std::<span class="pl-c1">size_t</span> ...N, <span class="pl-k">typename</span> Literal&gt;
argument&lt;Literal::get(N)...&gt; <span class="pl-en">make_argument</span>(std::index_sequence&lt;N...&gt;, Literal) {
  <span class="pl-k">return</span> {};
}

#<span class="pl-k">define</span> <span class="pl-en">MAKE_ARGUMENT</span>(<span class="pl-v">LITERAL</span>)                                              \
  <span class="pl-en">make_argument</span>(std::make_index_sequence&lt;<span class="pl-k">sizeof</span>(LITERAL)-1&gt;{}, []{          \
    <span class="pl-k">struct</span> <span class="pl-en">Literal</span> {                                                        \
      <span class="pl-k">static</span> <span class="pl-k">constexpr</span> <span class="pl-k">char</span> <span class="pl-en">get</span>(<span class="pl-k">int</span> i) { <span class="pl-k">return</span> LITERAL[i]; }               \
    };                                                                      \
    <span class="pl-k">return</span> Literal{};                                                       \
  }())                                                                      \
<span class="pl-c">/**/</span>

<span class="pl-c">// ... as before ...</span>

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
  <span class="pl-c1">create_window</span>(<span class="pl-c1">MAKE_ARGUMENT</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>) = <span class="pl-c1">20</span>, <span class="pl-c1">MAKE_ARGUMENT</span>(<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>) = <span class="pl-c1">50</span>,
                <span class="pl-c1">MAKE_ARGUMENT</span>(<span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span>) = <span class="pl-c1">100</span>, <span class="pl-c1">MAKE_ARGUMENT</span>(<span class="pl-s"><span class="pl-pds">"</span>height<span class="pl-pds">"</span></span>) = <span class="pl-c1">5</span>);
}</pre></div>

<p>Finally, defining string processing machinery is so non-trivial that even
runtime C++ lacks any useful form of it. The author thinks that dismissing
the proposed feature for lack of such machinery is unwise, since it blocks
a lot of use cases that are very basic in their string processing requirements
for the benefit of a few more advanced use cases. Furthermore, going forward
with this feature does not block us in any way from adding more advanced
machinery to the language later on. In fact, it may very well allow us to
gain more experience with what kind of machinery would be useful.</p>

<h2>
<a id="user-content-proposed-wording" class="anchor" href="#proposed-wording" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Proposed wording</h2>

<p>The wording initially proposed in <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html">N3599</a> still applies to the current draft
(<a href="https://github.com/cplusplus/draft/blob/master/papers/n4606.pdf">N4606</a>), and so it should be used. For convenience, it is copied here from
the original paper:</p>

<p>The term of art <em>literal operator template</em> is split into two terms, <em>numeric
literal operator template</em> and <em>string literal operator template</em>. The term
<em>literal operator template</em> is retained and refers to either form.</p>

<p>Replace "literal operator template" with "numeric literal operator template"
in <strong>[lex.ext] (2.14.8)/3</strong> and <strong>[lex.ext] (2.14.8)/4</strong>:</p>

<blockquote>
  [...] Otherwise, <i>S</i> shall contain a raw literal operator or a
  <ins>numeric</ins> literal operator template (13.5.8) but not both. [...]
  Otherwise (<i>S</i> contains a <ins>numeric</ins> literal operator template),
  <i>L</i> is treated as a call of the form [...]
</blockquote>

<p>Change in <strong>[lex.ext] (2.14.8)/5</strong>:</p>

<blockquote>
  If <i>L</i> is a <i>user-defined-string-literal</i>, <ins>let <i>C</i> be the
  element type of the string literal as determined by its
  <i>encoding-prefix</i>,</ins> let <i>str</i> be the literal without its
  <i>ud-suffix</i><ins>,</ins> and let <i>len</i> be the number of code units in
  <i>str</i> (i.e., its length excluding the terminating null character).
  <ins>If <i>S</i> contains a literal operator with parameter types <code>const
  <i>C</i> *</code> and <code>std::size_t</code>, the</ins> <del>The</del> literal
  <i>L</i> is treated as a call of the form

  <code>  operator "" <i>X</i>(<i>str</i>, <i>len</i>)</code>

  <ins>
  <p>Otherwise, <i>S</i> shall contain a string literal operator template
  (13.5.8), and <i>L</i> is treated as a call of the form</p>

  <code>  operator "" <i>X</i>&lt;<i>C</i>,
    <i>e</i>'<i>s<sub>1</sub></i>',
    <i>e</i>'<i>s<sub>2</sub></i>', ...
    <i>e</i>'<i>s<sub>k</sub></i>'&gt;()</code>

  where <i>e</i> is empty when the <i>encoding-prefix</i> is <code>u8</code>
  and is otherwise the <i>encoding-prefix</i> of the string literal, and
  <i>str</i> contains the sequence of code units
  <i>s<sub>1</sub>s<sub>2</sub>...s<sub>k</sub></i> (excluding the terminating null
  character).
  </ins>
</blockquote>

<p>Change in <strong>[over.literal] (13.5.8)/5</strong>:</p>

<blockquote>
  <del>
  The declaration of a literal operator template shall have an empty
  <i>parameter-declaration-clause</i> and its <i>template-parameter-list</i>
  shall have
  </del>

  <ins>A <i>numeric literal operator template</i> is a literal operator template
  whose <i>template-parameter-list</i> has</ins>

  a single <i>template-parameter</i> that is a non-type template parameter pack
  (14.5.3) with element type <code>char</code>.

  <ins>A <i>string literal operator template</i> is a literal operator template
  whose <i>template-parameter-list</i> comprises
  a type <i>template-parameter</i> <i>C</i> followed by a non-type template
  parameter pack with element type <i>C</i>.

  The declaration of a literal operator template shall have an empty
  <i>parameter-declaration-clause</i> and shall declare either a numeric literal
  operator template or a string literal operator template.
  </ins>
</blockquote>

<h2>
<a id="user-content-acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Acknowledgements</h2>

<p>Richard Smith for doing all the hard work in <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html">N3599</a>.</p>


</article></body></html>