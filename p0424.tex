\documentclass{wg21}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{minted}
\usepackage{enumitem}

\lstdefinestyle{base}{
  language=c++,
  breaklines=false,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{green!50!black}]{@}{@},
  escapeinside={(*@}{@*)}
}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}


\title{String literals as non-type template parameters}
\docnumber{D0424R2}
\audience{Evolution Working Group}
\author{Louis Dionne}{ldionne.2@gmail.com}
\authortwo{Hana Dus\'{i}kov\'{a}}{hanicka@hanicka.net}

\begin{document}
\maketitle


\section{Revision history}
\begin{itemize}
  \item R0 -- Initial draft
  \item R1 -- Rewrite with different UDL form per EWG direction, and update motivation.
  \item R2 -- Incorporate feedback from EWG in Albuquerque:
              \begin{itemize}
                \item Use array syntax instead of pointer and length.
                \item Allow string literals as non-type template arguments.
                \item TODO: Propose some wording.
              \end{itemize}
\end{itemize}


\section{Abstract}
We propose allowing string literals as non-type template arguments. A string
literal would be passed as a reference to an array of characters:

\begin{cpp}
template <auto& str>
void foo();

foo<"hello">(); // calls foo with array {'h', 'e', 'l', 'l', 'o', '\0'}
\end{cpp}

To match this new functionality, we also propose adding a new form of the
user-defined literal operator for strings:

\begin{cpp}
template <auto& str>
auto operator"" _udl();

"hello"_udl; // equivalent to operator""_udl<"hello">()
\end{cpp}


\section{Motivation}
Compile-time strings are a sorely missed piece of functionality in C++.
Indeed, while we can pass a string as a function argument, there is no way
of getting a string as a compile-time entity from within a function. This
prevents a function from creating an object whose type depends on the
\emph{contents} of the string being passed. This paper proposes solving
this problem by allowing string literals as non-type template parameters.

There are many concrete use cases for this functionality, some of which were
covered in a previous version of this paper (\cite{P0424R0}). However, some
interesting use cases have recently come up, the most notable ones being
compile-time JSON parsing and compile-time regular expression parsing. For
example, a regular expression engine can be generated at compile-time as
follows (example taken from the \cite{CTRE} library):

\begin{cpp}
#include "pregexp.hpp"
using namespace sre;

auto regexp = "^(?:[abc]|xyz).+$"_pre;

int main(int argc, char** argv) {
  if (regexp.match(argv[1])) {
    std::cout << "match!" << std::endl;
    return EXIT_SUCCESS;
  } else {
    std::cout << "no match!" << std::endl;
    return EXIT_FAILURE;
  }
}
\end{cpp}

Under the hood, constexpr functions and metaprogramming are used to parse the
string literal and generate a type like the following from the string literal:

\begin{cpp}
RegExp<
  Begin,
  Select<Char<'a','b','c'>, String<'x','y','z'>>,
  Plus<Anything>,
  End
>
\end{cpp}

Since the regular expression parser is generated at compile-time, it can be
better optimized and the resulting code is much faster than \cc{std::regex}
(speedups of 3000x have been witnessed).

Similar functionality has traditionally been achieved by using expression
templates and template metaprogramming to build the representation of the
regular expression instead of simply parsing the string at compile-time.
For example, the same regular expression with \cite{Boost.Xpressive} looks
like this:

\begin{cpp}
auto regexp = bos >> ((set='a','b','c')|(as_xpr('x') >> 'y' >> 'z')) >> +_ >> eos;
\end{cpp}

It is worth noting that the specific use case of parsing regular expressions
at compile-time came up at CppCon during a lightning talk, and the room showed
a very strong interest in getting a standardized solution to this problem.
Today, we must rely on a non-standard extension provided by Clang and GCC,
which allows user-defined literal operators of the following form to be
considered for string literals:

\begin{cpp}
template <typename CharT, CharT ...s>
constexpr auto operator"" _udl();

"foo"_udl // calls operator""_udl<char, 'f', 'o', 'o'>()
\end{cpp}

With this proposal, we could instead write the following:

\begin{cpp}
auto regexp = sre::parse<"^(?:[abc]|xyz).+$">();
\end{cpp}

or, for those that prefer user-defined literals:

\begin{cpp}
using namespace sre;
auto regexp = "^(?:[abc]|xyz).+$"_pre;
\end{cpp}


\section{How would that work?}
The idea behind how this would work is that the compiler would generate a
constexpr array and pass a reference to that as a template argument:

\begin{cpp}
template <auto& str>
void f() {
  // str is a `char const (&)[7]`
}

f<"foobar">();

// should be roughly equivalent to

inline constexpr char __unnamed[] = "foobar";
f<__unnamed>();
\end{cpp}

Calling a function template with such a template-parameter-list works in
both \href{https://wandbox.org/permlink/zOOIb472ak9nBNMt}{Clang} and
\href{https://wandbox.org/permlink/8zpg3CLqzi9VTiuE}{GCC} today.


\section{Proposed wording}
TODO


\section{Potential generalization}
We could potentially make this applicable to arrays of arbitrary types,
with something like the following syntax:

\begin{cpp}
template <auto& array> void f();

f<{1, 2, 3}>(); // calls f with an array of type `int (&)[3]`
\end{cpp}

This is an interesting generalization, but the author prefers tackling
that as part of a separate proposal, since this proposal only targets
string literals and is very useful on its own.


\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

  \bibitem[P0424R0]{P0424R0}
    Louis Dionne,
    \emph{Reconsidering literal operator templates for strings}\newline
    \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf}

  \bibitem[Boost.Xpressive]{Boost.Xpressive}
    Eric Niebler,
    \emph{Boost.Xpressive}\newline
    \url{http://www.boost.org/doc/libs/release/doc/html/xpressive.html}

  \bibitem[CTRE]{CTRE}
    Hana Dus\'{i}kov\'{a}
    \emph{Compile Time Regular Expression library}\newline
    \url{https://github.com/hanickadot/compile-time-regular-expressions}

\end{thebibliography}

\end{document}
